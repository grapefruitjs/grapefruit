<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/audio/AudioPlayer.js - GrapeFruit Game Engine</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="https://en.gravatar.com/userimage/49218683/8654d0c767f327312ebb1ace7f5a8d8d.png" title="GrapeFruit Game Engine"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v0.0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/gf.AnimatedSprite.html">gf.AnimatedSprite</a></li>
            
                <li><a href="../classes/gf.AssetLoader.html">gf.AssetLoader</a></li>
            
                <li><a href="../classes/gf.AudioLoader.html">gf.AudioLoader</a></li>
            
                <li><a href="../classes/gf.AudioManager.html">gf.AudioManager</a></li>
            
                <li><a href="../classes/gf.AudoPlayer.html">gf.AudoPlayer</a></li>
            
                <li><a href="../classes/gf.Camera.html">gf.Camera</a></li>
            
                <li><a href="../classes/gf.Circle.html">gf.Circle</a></li>
            
                <li><a href="../classes/gf.Clock.html">gf.Clock</a></li>
            
                <li><a href="../classes/gf.DisplayObjectContainer.html">gf.DisplayObjectContainer</a></li>
            
                <li><a href="../classes/gf.Ellipse.html">gf.Ellipse</a></li>
            
                <li><a href="../classes/gf.EventEmitter.html">gf.EventEmitter</a></li>
            
                <li><a href="../classes/gf.Game.html">gf.Game</a></li>
            
                <li><a href="../classes/gf.GameState.html">gf.GameState</a></li>
            
                <li><a href="../classes/gf.Gui.html">gf.Gui</a></li>
            
                <li><a href="../classes/gf.GuiItem.html">gf.GuiItem</a></li>
            
                <li><a href="../classes/gf.ImageLayer.html">gf.ImageLayer</a></li>
            
                <li><a href="../classes/gf.input.Gamepad.html">gf.input.Gamepad</a></li>
            
                <li><a href="../classes/gf.input.GamepadButtons.html">gf.input.GamepadButtons</a></li>
            
                <li><a href="../classes/gf.input.GamepadSticks.html">gf.input.GamepadSticks</a></li>
            
                <li><a href="../classes/gf.input.Input.html">gf.input.Input</a></li>
            
                <li><a href="../classes/gf.input.Keyboard.html">gf.input.Keyboard</a></li>
            
                <li><a href="../classes/gf.InputManager.html">gf.InputManager</a></li>
            
                <li><a href="../classes/gf.JsonLoader.html">gf.JsonLoader</a></li>
            
                <li><a href="../classes/gf.Layer.html">gf.Layer</a></li>
            
                <li><a href="../classes/gf.Loader.html">gf.Loader</a></li>
            
                <li><a href="../classes/gf.Map.html">gf.Map</a></li>
            
                <li><a href="../classes/gf.math.html">gf.math</a></li>
            
                <li><a href="../classes/gf.ObjectPool.html">gf.ObjectPool</a></li>
            
                <li><a href="../classes/gf.PhysicsTarget.html">gf.PhysicsTarget</a></li>
            
                <li><a href="../classes/gf.plugin.html">gf.plugin</a></li>
            
                <li><a href="../classes/gf.Point.html">gf.Point</a></li>
            
                <li><a href="../classes/gf.Polygon.html">gf.Polygon</a></li>
            
                <li><a href="../classes/gf.Rectangle.html">gf.Rectangle</a></li>
            
                <li><a href="../classes/gf.Sprite.html">gf.Sprite</a></li>
            
                <li><a href="../classes/gf.SpritePool.html">gf.SpritePool</a></li>
            
                <li><a href="../classes/gf.support.html">gf.support</a></li>
            
                <li><a href="../classes/gf.Texture.html">gf.Texture</a></li>
            
                <li><a href="../classes/gf.TextureFont.html">gf.TextureFont</a></li>
            
                <li><a href="../classes/gf.TextureLoader.html">gf.TextureLoader</a></li>
            
                <li><a href="../classes/gf.Tile.html">gf.Tile</a></li>
            
                <li><a href="../classes/gf.TiledLayer.html">gf.TiledLayer</a></li>
            
                <li><a href="../classes/gf.TiledMap.html">gf.TiledMap</a></li>
            
                <li><a href="../classes/gf.TiledObjectGroup.html">gf.TiledObjectGroup</a></li>
            
                <li><a href="../classes/gf.TiledTileset.html">gf.TiledTileset</a></li>
            
                <li><a href="../classes/gf.utils.html">gf.utils</a></li>
            
                <li><a href="../classes/gf.Vector.html">gf.Vector</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/audio/AudioPlayer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Grapefruit Audio API, provides an easy interface to use HTML5 Audio
 * The GF Audio API was based on
 * &lt;a target=&quot;_blank&quot; href=&quot;https://github.com/goldfire/howler.js&quot;&gt;Howler.js&lt;/a&gt;
 *
 * @class AudoPlayer
 * @extends Object
 * @uses gf.EventEmitter
 * @namespace gf
 * @constructor
 * @param manager {AudioManager} AudioManager instance for this audio player
 * @param settings {Object} All the settings for this player instance
 */
gf.AudioPlayer = function(manager, settings) {
    gf.EventEmitter.call(this);

    /**
     * The source of the audio, the actual URL to load up
     *
     * @property src
     * @type String
     */
    this.src = &#x27;&#x27;;

    /**
     * Play the audio immediately after loading
     *
     * @property autoplay
     * @type Boolean
     * @default false
     */
    this.autoplay = false;

    /**
     * Buffer forces use of HTML5Audio which will buffer and play
     * instead of loading the entire file and then playing
     *
     * @property buffer
     * @type Boolean
     * @default false
     */
    this.buffer = false;

    /**
     * Override the format determined from the extension with this extension
     *
     * @property format
     * @type String
     * @default null
     */
    this.format = null;

    /**
     * Replay the audio immediately after finishing
     *
     * @property loop
     * @type Boolean
     * @default false
     */
    this.loop = false;

    /**
     * A 3D position where the audio should sound like it is coming from
     *
     * @property pos3d
     * @type Array&lt;Number&gt;
     * @default [0, 0, -0.5]
     */
    this.pos3d = [0, 0, -0.5];

    /**
     * A sound sprite that maps string keys to [start, duration] arrays. These can
     * be used to put multiple sound bits in one file, and play them separately
     *
     * @property sprite
     * @type Object
     * @default {}
     */
    this.sprite = {};

    /**
     * The volume of the audio player
     *
     * @property volume
     * @type Number
     * @default 1
     */
    Object.defineProperty(this, &#x27;volume&#x27;, {
        get: this.getVolume.bind(this),
        set: this.setVolume.bind(this)
    });

    this._volume = 1;
    this._duration = 0;
    this._loaded = false;
    this._manager = manager;
    this._canPlay = manager.canPlay;
    this._codecs = manager.codecs;
    this._webAudio = gf.support.webAudio &amp;&amp; !this.buffer;
    this._nodes = [];
    this._onendTimer = [];

    //mixin user&#x27;s settings
    gf.utils.setValues(this, settings);

    if(this._webAudio) {
        this._setupAudioNode();
    }

    this.load();
};

gf.inherits(gf.AudioPlayer, Object, {
    /**
     * Load the audio file for this player, this is called from the ctor
     * there is no reason to call it manually.
     *
     * @method load
     * @return {AudioPlayer}
     * @private
     */
    load: function() {
        //if using web audio, load up the buffer
        if(this._webAudio) {
            this.loadBuffer(this.src);
        }
        //otherwise create some Audio nodes
        else {
            //create a new adio node
            var node = new Audio();
            this._nodes.push(node);

            //setup the audio node
            node.src = this.src;
            node._pos = 0;
            node.preload = &#x27;auto&#x27;;
            node.volume = this._manager.muted ? 0 : this._volume * this._manager.volume;

            //setup the event listener to start playing the sound when it has buffered
            var self = this, evt = function() {
                self._duration = node.duration;

                //setup a default sprite
                self.sprite._default = [0, node.duration * 1000];

                //check if loaded
                if(!self._loaded) {
                    self._loaded = true;
                    self.emit(&#x27;load&#x27;, {
                        message: &#x27;Audio file loaded.&#x27;,
                        data: self.src
                    });
                }

                //if autoplay then start it
                if(self.autoplay) {
                    self.play();
                }

                //clear the event listener
                node.removeEventListener(&#x27;canplaythrough&#x27;, evt, false);
            };
            node.addEventListener(&#x27;canplaythrough&#x27;, evt, false);
            node.load();
        }

        return this;
    },
    /**
     * Play a sound from the current time (0 by default).
     *
     * @method play
     * @param [sprite] {String} Plays from the specified position in the sound sprite definition.
     * @param [callback] {Function} Returns the unique playback id for this sound instance.
     * @return {AudioPlayer}
     */
    play: function(sprite, cb) {
        var self = this;

        if(typeof sprite === &#x27;function&#x27;) {
            cb = sprite;
            sprite = null;
        }

        //if no sprite specified, use default
        if(!sprite) {
            sprite = &#x27;_default&#x27;;
        }

        //if we haven&#x27;t loaded yet, wait until we do
        if(!this._loaded) {
            this.on(&#x27;load&#x27;, function() {
                self.play(sprite, cb);
            });

            return this;
        }

        //if the sprite doesn&#x27;t exist, play nothing
        if(!this.sprite[sprite]) {
            if(typeof cb === &#x27;function&#x27;) cb();
            return this;
        }

        //get an audio node to use to play
        this._inactiveNode(function(node) {
            var pos = node._pos &gt; 0 ? node._pos : self.sprite[sprite][0] / 1000,
            duration = (self.sprite[sprite][1] / 1000) - node._pos,
            loop = (self.loop || self.sprite[sprite][2]),
            soundId = (typeof cb === &#x27;string&#x27;) ? cb : (Math.round(Date.now() * Math.random()) + &#x27;&#x27;),
            timerId;

            node._sprite = sprite;

            //after the audio finishes:
            (function(o) {
                timerId = setTimeout(function() {
                    //if looping restsart it
                    if(!self._webAudio &amp;&amp; o.loop) {
                        self.stop(o.id, o.timer).play(o.sprite, o.id);
                    }

                    // set web audio node to paused
                    if(self._webAudio &amp;&amp; !o.loop) {
                        self._nodeById(o.id).paused = true;
                    }

                    //end the track if it is HTML audio and a sprite
                    if(!self._webAudio &amp;&amp; !o.loop) {
                        self.stop(o.id, o.timer);
                    }

                    //fire off the end event
                    self.emit(&#x27;end&#x27;, {
                        message: &#x27;Audio has finished playing&#x27;,
                        data: o.id
                    });
                }, duration * 1000);

                //store the timer
                self._onendTimer.push(timerId);

                //remember which timer to kill
                o.timer = timerId;
            })({
                id: soundId,
                sprite: sprite,
                loop: loop
            });

            //setup webAudio functions
            if(self._webAudio) {
                //set the play id to this node and load into context
                node.id = soundId;
                node.paused = false;
                self.refreshBuffer([loop, pos, duration], soundId);
                self._playStart = self._manager.ctx.currentTime;
                node.gain.value = self._volume;

                if(typeof node.bufferSource.start === &#x27;undefined&#x27;) {
                    node.bufferSource.noteGrainOn(0, pos, duration);
                } else {
                    node.bufferSource.start(0, pos, duration);
                }
            } else {
                if(node.readyState === 4) {
                    node.id = soundId;
                    node.currentTime = pos;
                    node.muted = self._manager.muted;
                    node.volume = self._volume * self._manager.volume;
                    node.play();
                } else {
                    self._clearEndTimer(timerId);

                    (function() {
                        var sound = self,
                            playSpr = sprite,
                            fn = cb,
                            newNode = node;

                        var evt = function() {
                            sound.play(playSpr, fn);

                            //clear listener
                            newNode.removeEventListener(&#x27;canplaythrough&#x27;, evt, false);
                        };
                        newNode.addEventListener(&#x27;canplaythrough&#x27;, evt, false);
                    })();

                    return self;
                }
            }

            self.emit(&#x27;play&#x27;, {
                message: &#x27;Playing audio file&#x27;,
                data: soundId
            });

            if(typeof cb === &#x27;function&#x27;)
                cb(soundId);
        });

        return this;
    },
    /**
     * Pause playback and save the current position.
     *
     * @method pause
     * @param [id] {String} The play instance ID.
     * @param [timerId] {String} Clear the correct timeout ID.
     * @return {AudioPlayer}
     */
    pause: function(id, timerId) {
        var self = this;

        //if we haven&#x27;t loaded this sound yet, wait until we play it to pause it
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.play(id);
            });

            return this;
        }

        //clear the onend timer
        this._clearEndTimer(timerId || 0);

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            if(this._webAudio) {
                //ensure the sound was created
                if(!activeNode.bufferSource)
                    return this;

                activeNode.paused = true;
                activeNode._pos += this._manager.ctx.currentTime - this._playStart;

                if(typeof activeNode.bufferSource.stop === &#x27;undefined&#x27;) {
                    activeNode.bufferSource.noteOff(0);
                } else {
                    activeNode.bufferSource.stop(0);
                }
            } else {
                activeNode._pos = activeNode.currentTime;
                activeNode.pause();
            }
        }

        this.emit(&#x27;pause&#x27;, {
            message: &#x27;Audio file paused&#x27;,
            data: id
        });

        return this;
    },
    /**
     * Stop playback and reset to start.
     *
     * @method stop
     * @param [id] {String} The play instance ID.
     * @param [timerId] {String} Clear the correct timeout ID.
     * @return {AudioPlayer}
     */
    stop: function(id, timerId) {
        var self = this;

        //if we haven&#x27;t loaded this sound yet, wait until we play it to stop it
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.stop(id);
            });

            return this;
        }

        //clear onend timer
        this._clearEndTimer(timerId || 0);

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            activeNode._pos = 0;

            if(this._webAudio) {
                if(!activeNode.bufferSource)
                    return this;

                activeNode.paused = true;

                if(typeof activeNode.bufferSource.stop === &#x27;undefined&#x27;) {
                    activeNode.bufferSource.noteOff(0);
                } else {
                    activeNode.bufferSource.stop(0);
                }
            } else {
                activeNode.pause();
                activeNode.currentTime = 0;
            }
        }

        return this;
    },
    /**
     * Mute this sound.
     *
     * @method mute
     * @param [id] {String} The play instance ID.
     * @return {AudioPlayer}
     */
    mute: function(id) {
        return this.setMuted(true, id);
    },
    /**
     * Unmute this sound.
     *
     * @method unmute
     * @param [id] {String} The play instance ID.
     * @return {AudioPlayer}
     */
    unmute: function(id) {
        return this.setMuted(false, id);
    },
    /**
     * Set the muted state of this sound.
     *
     * @method setMuted
     * @param muted {Boolean}
     * @param [id] {String} The play instance ID.
     * @return {AudioPlayer}
     */
    setMuted: function(muted, id) {
        var self  = this;

        //if we haven&#x27;t loaded this sound yet, wait until we play it to mute it
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.setMuted(muted, id);
            });

            return this;
        }

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            if(this._webAudio) {
                activeNode.gain.value = muted ? 0 : this._volume;
            } else {
                activeNode.volume =  muted ? 0 : this._volume;
            }
        }

        return this;
    },
    /**
     * Set the position of playback.
     *
     * @method seek
     * @param pos {Number} The position to move current playback to.
     * @param [id] {String} The play instance ID.
     * @return {AudioPlayer}
     */
    seek: function(pos, id) {
        var self = this;

        //if we haven&#x27;t loaded this sound yet, wait until it is to seek it
        if(!this._loaded) {
            this.on(&#x27;load&#x27;, function() {
                self.seek(pos);
            });

            return this;
        }

        //if position is &lt; 0, or invalid, then set to 0
        if(!pos || pos &lt; 0)
            pos = 0;

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            if(this._webAudio) {
                activeNode._pos = pos;
                this.pause(activeNode.id).play(activeNode._sprite, id);
            } else {
                activeNode.currentTime = pos;
            }
        }

        return this;
    },
    /**
     * Get the position of playback.
     *
     * @method getPosition
     * @param [id] {String} The play instance ID.
     * @return {Number}
     */
    getPosition: function(id) {
        var self = this;

        //if we haven&#x27;t loaded this sound yet, wait until it is to seek it
        if(!this._loaded) {
            this.on(&#x27;load&#x27;, function() {
                self.getPosition(id);
            });

            return this;
        }

        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if(activeNode) {
            if(this._webAudio) {
                return activeNode._pos + (this._manager.ctx.currentTime - this._playStart);
            } else {
                return activeNode.currentTime;
            }
        }

        return 0;
    },
    /**
     * Fade a currently playing sound between two volumes.
     *
     * @method fade
     * @param from {Number} The volume to fade from (0.0 to 1.0).
     * @param to {Number} The volume to fade to (0.0 to 1.0).
     * @param len {Number} Time in milliseconds to fade.
     * @param [id] {String} The play instance ID.
     * @param [callback] {Function} Fired when the fade is complete.
     * @return {AudioPlayer}
     */
    fade: function(from, to, len, id, cb) {
        var self = this,
            diff = Math.abs(from - to),
            dir = from &gt; to ? &#x27;dowm&#x27; : &#x27;up&#x27;,
            steps = diff / 0.01,
            stepTime = len / steps;

        if(typeof id === &#x27;function&#x27;) {
            cb = id;
            id = null;
        }

        //if we haven&#x27;t loaded this sound yet, wait until it is to seek it
        if(!this._loaded) {
            this.on(&#x27;load&#x27;, function() {
                self.fade(from, to, len, id, cb);
            });

            return this;
        }

        this.setVolume(from, id);

        for(var i = 1; i &lt;= steps; ++i) {
            var change = this._volume + ((dir === &#x27;up&#x27; ? 0.01 : -0.01) * i),
                vol = Math.round(1000 * change) / 1000,
                wait = stepTime * i;

            this._doFadeStep(vol, wait, to, id, cb);
        }
    },
    /**
     * Returns the current volume of the player
     *
     * @method getVolume
     * @return {Number} The current volume
     */
    getVolume: function() {
        return this._volume;
    },
    /**
     * Sets the current volume of the player
     *
     * @method setVolume
     * @param vol {Number} The current volume
     * @param [id] {String} The play instance ID.
     * @return {AudioPlayer}
     */
    setVolume: function(vol, id) {
        var self = this;

        // make sure volume is a number
        vol = parseFloat(vol);

        //if we haven&#x27;t loaded this sound yet, wait until we play it to change the volume
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.setVolume(vol, id);
            });

            return this;
        }

        //set the volume
        if(vol &gt;= 0 &amp;&amp; vol &lt;= 1) {
            this._volume = vol;

            var activeNode = id ? this._nodeById(id) : this._activeNode();
            if(activeNode) {
                if(this._webAudio) {
                    activeNode.gain.volume = vol;
                } else {
                    activeNode.volume = vol * this._manager.volume;
                }
            }
        }

        return this;
    },
    /**
     * Set the 3D position of the audio source.
     * The most common usage is to set the &#x27;x&#x27; position
     * to affect the left/right ear panning. Setting any value higher than
     * 1.0 will begin to decrease the volume of the sound as it moves further away.
     * NOTE: This only works with Web Audio API, HTML5 Audio playback
     * will not be affected.
     *
     * @method setPosition
     * @param x {Number} The x-position of the playback from -1000.0 to 1000.0
     * @param y {Number} The y-position of the playback from -1000.0 to 1000.0
     * @param z {Number} The z-position of the playback from -1000.0 to 1000.0
     * @param [id] {String} The play instance ID.
     * @return {AudioPlayer}
     */
    setPosition: function(x, y, z, id) {
        var self = this;

        //set a default for the optional &#x27;y&#x27; and &#x27;z&#x27;
        x = !x ? 0 : x;
        y = !y ? 0 : y;
        z = (!z &amp;&amp; z !== 0) ? -0.5 : z;

        //if we haven&#x27;t loaded this sound yet, wait until we play it to change the position
        if(!this._loaded) {
            this.on(&#x27;play&#x27;, function() {
                self.setPosition(x, y, z, id);
            });

            return this;
        }

        if(this._webAudio) {
            var activeNode = id ? this._nodeById(id) : this._activeNode();
            if(activeNode) {
                this.pos3d[0] = x;
                this.pos3d[1] = y;
                this.pos3d[2] = z;
                activeNode.panner.setPosition(x, y, z);
            }
        }

        return this;
    },
    /**
     * Performs a step in the fade transition
     *
     * @method _doFadeStep
     * @private
     */
    _doFadeStep: function(vol, wait, end, id, cb) {
        var self = this;

        setTimeout(function() {
            self.setVolume(vol, id);

            if(vol === end) {
                if(typeof cb === &#x27;function&#x27;)
                    cb();
            }
        }, wait);
    },
    /**
     * Get an audio node by ID.
     *
     * @method _nodeById
     * @return {AudioPlayer} Audio node.
     * @private
     */
    _nodeById: function(id) {
        var node = this._nodes[0]; //default return value

        //find the node with this ID
        for(var i = 0, il = this._nodes.length; i &lt; il; ++i) {
            if(this._nodes[i].id === id) {
                node = this._nodes[i];
                break;
            }
        }

        return node;
    },
    /**
     * Get the first active audio node.
     *
     * @method _activeNode
     * @return {AudioPlayer} Audio node.
     * @private
     */
    _activeNode: function() {
        var node;

        //find the first playing node
        for(var i = 0, il = this._nodes.length; i &lt; il; ++i) {
            if(!this._nodes[i].paused) {
                node = this._nodes[i];
                break;
            }
        }

        //remove excess inactive nodes
        this._drainPool();

        return node;
    },
    /**
     * Get the first inactive audio node.
     * If there is none, create a new one and add it to the pool.
     *
     * @method _inactiveNode
     * @param cb {Function} callback Function to call when the audio node is ready.
     * @private
     */
    _inactiveNode: function(cb) {
        var node;

        //find first inactive node to recycle
        for(var i = 0, il = this._nodes.length; i &lt; il; ++i) {
            if(this._nodes[i].paused &amp;&amp; this._nodes[i].readyState === 4) {
                cb(node = this._nodes[i]);
                break;
            }
        }

        //remove excess inactive nodes
        this._drainPool();

        if(node) return;

        //create new node if there are no inactives
        if(this._webAudio) {
            node = this._setupAudioNode();
            cb(node);
        } else {
            this.load();
            node = this._nodes[this.nodes.length - 1];
            node.addEventListener(&#x27;loadedmetadata&#x27;, function() {
                cb(node);
            });
        }
    },
    /**
     * If there are more than 5 inactive audio nodes in the pool, clear out the rest.
     *
     * @method _drainPool
     * @private
     */
    _drainPool: function() {
        var inactive = 0,
            i = 0, il = 0;

        //count inactive nodes
        for(i = 0, il = this._nodes.length; i &lt; il; ++i) {
            if(this._nodes[i].paused) {
                inactive++;
            }
        }

        //remove excess inactive nodes
        for(i = this._nodes.length; i &gt;= 0; --i) {
            if(inactive &lt;= 5)
                break;

            if(this._nodes[i].paused) {
                inactive--;
                this._nodes.splice(i, 1);
            }
        }
    },
    /**
     * Clear &#x27;onend&#x27; timeout before it ends.
     *
     * @method _clearEndTimer
     * @param timerId {Number} timerId The ID of the sound to be cancelled.
     * @private
     */
    _clearEndTimer: function(timerId) {
        var timer = this._onendTimer.indexOf(timerId);

        //make sure the timer is cleared
        timer = timer &gt;= 0 ? timer : 0;

        if(this._onendTimer[timer]) {
            clearTimeout(this._onendTimer[timer]);
            this._onendTimer.splice(timer, 1);
        }
    },
    /**
     * Setup the gain node and panner for a Web Audio instance.
     *
     * @method _setupAudioNode
     * @return {Object} The new audio node.
     * @private
     */
    _setupAudioNode: function() {
        var node = this._nodes,
            i = this._nodes.length;

        //create gain node
        node.push((typeof this._manager.ctx.createGain === &#x27;undefined&#x27;) ? this._manager.ctx.createGainNode : this._manager.ctx.createGain());
        node[i].gain.value = this._volume;
        node[i].paused = true;
        node[i]._pos = 0;
        node[i].readyState = 4;
        node[i].connect(this._manager.masterGain);

        //create the panner
        node[i].panner = this._manager.ctx.createPanner();
        node[i].panner.setPosition(this.pos3d[0], this.pos3d[1], this.pos3d[2]);
        node[i].panner.connect(node[i]);

        return node[i];
    }
});

//define some prototype functions that are only available when using the WebAudio API
if(gf.support.webAudio) {
    /**
     * Buffer a sound from URL (or from cache) and decode to audio source (Web Audio API).
     *
     * @method loadBuffer
     * @param url {String} The path to the sound file.
     * @private
     */
    gf.AudioPlayer.prototype.loadBuffer = function(url) {
        //load from cache
        if(url in gf.assetCache) {
            this._duration = gf.assetCache[url].duration;
            this.loadSound();
        } else {
            //load the buffer from the URL
            var self = this;

            gf.utils.ajax({
                method: &#x27;GET&#x27;,
                url: url,
                dataType: &#x27;arraybuffer&#x27;,
                load: function(data) {
                    //decode the buffer into an audio source
                    self._manager.ctx.decodeAudioData(data, function(buffer) {
                        if(buffer) {
                            gf.assetCache[url] = buffer;
                            self.loadSound(buffer);
                        }
                    });
                },
                error: function() {
                    //if there was an error, switch to HTML Audio
                    if(self._webAudio) {
                        self._buffer = true;
                        self._webAudio = false;
                        self._nodes = [];
                        self.load();
                    }
                }
            });
        }
    };

    /**
     * Finishes loading the Web Audio API sound and fires the loaded event
     *
     * @method loadSound
     * @param buffer {Object} The decoded buffer sound source.
     * @private
     */
    gf.AudioPlayer.prototype.loadSound = function(buffer) {
        this._duration = buffer ? buffer.duration : this._duration;

        //setup a default sprite
        this.sprite._default = [0, this._duration * 1000];

        //fire the load event
        if(!this._loaded) {
            this._loaded = true;
            this.emit(&#x27;load&#x27;, {
                message: &#x27;Audio file loaded.&#x27;,
                data: this.src
            });
        }

        //autoplay is appropriate
        if(this.autoplay) {
            this.play();
        }
    };

    /**
     * Load the sound back into the buffer source.
     *
     * @method refreshBuffer
     * @param loop {Array} Loop boolean, pos, and duration.
     * @param [id] {String} The play instance ID.
     * @private
     */
    gf.AudioPlayer.prototype.refreshBuffer = function(loop, id) {
        var node = this._nodeById(id);

        //setup the buffer source for playback
        node.bufferSource = this._manager.ctx.createBufferSource();
        node.bufferSource.buffer = gf.assetCache[this.src];
        node.bufferSource.connect(node.panner);
        node.bufferSource.loop = loop[0];

        if(loop[0]) {
            node.bufferSource.loopStart = loop[1];
            node.bufferSource.loopEnd = loop[1] + loop[2];
        }
    };
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
