<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\tilemap\Tilelayer.js - GrapeFruit Game Engine</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="https://en.gravatar.com/userimage/49218683/8654d0c767f327312ebb1ace7f5a8d8d.png" title="GrapeFruit Game Engine"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/ATLAS_FORMAT.html">ATLAS_FORMAT</a></li>
            
                <li><a href="../classes/AudioManager.html">AudioManager</a></li>
            
                <li><a href="../classes/AudioPlayer.html">AudioPlayer</a></li>
            
                <li><a href="../classes/AXIS.html">AXIS</a></li>
            
                <li><a href="../classes/BaseTexture.html">BaseTexture</a></li>
            
                <li><a href="../classes/BitmapText.html">BitmapText</a></li>
            
                <li><a href="../classes/Cache.html">Cache</a></li>
            
                <li><a href="../classes/Camera.html">Camera</a></li>
            
                <li><a href="../classes/CAMERA_FOLLOW.html">CAMERA_FOLLOW</a></li>
            
                <li><a href="../classes/Circle.html">Circle</a></li>
            
                <li><a href="../classes/Clock.html">Clock</a></li>
            
                <li><a href="../classes/Container.html">Container</a></li>
            
                <li><a href="../classes/DIRECTION.html">DIRECTION</a></li>
            
                <li><a href="../classes/Ellipse.html">Ellipse</a></li>
            
                <li><a href="../classes/EventEmitter.html">EventEmitter</a></li>
            
                <li><a href="../classes/FILE_FORMAT.html">FILE_FORMAT</a></li>
            
                <li><a href="../classes/fx.camera.Close.html">fx.camera.Close</a></li>
            
                <li><a href="../classes/fx.camera.Effect.html">fx.camera.Effect</a></li>
            
                <li><a href="../classes/fx.camera.Fade.html">fx.camera.Fade</a></li>
            
                <li><a href="../classes/fx.camera.Flash.html">fx.camera.Flash</a></li>
            
                <li><a href="../classes/fx.camera.Scanlines.html">fx.camera.Scanlines</a></li>
            
                <li><a href="../classes/fx.camera.Shake.html">fx.camera.Shake</a></li>
            
                <li><a href="../classes/Game.html">Game</a></li>
            
                <li><a href="../classes/Gamepad.html">Gamepad</a></li>
            
                <li><a href="../classes/GamepadButtons.html">GamepadButtons</a></li>
            
                <li><a href="../classes/GamepadSticks.html">GamepadSticks</a></li>
            
                <li><a href="../classes/Graphics.html">Graphics</a></li>
            
                <li><a href="../classes/GuiItem.html">GuiItem</a></li>
            
                <li><a href="../classes/Input.html">Input</a></li>
            
                <li><a href="../classes/InputManager.html">InputManager</a></li>
            
                <li><a href="../classes/Keyboard.html">Keyboard</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/math.html">math</a></li>
            
                <li><a href="../classes/ObjectFactory.html">ObjectFactory</a></li>
            
                <li><a href="../classes/ObjectGroup.html">ObjectGroup</a></li>
            
                <li><a href="../classes/ObjectPool.html">ObjectPool</a></li>
            
                <li><a href="../classes/ParticleEmitter.html">ParticleEmitter</a></li>
            
                <li><a href="../classes/ParticleSystem.html">ParticleSystem</a></li>
            
                <li><a href="../classes/PhysicsSystem.html">PhysicsSystem</a></li>
            
                <li><a href="../classes/PhysicsTarget.html">PhysicsTarget</a></li>
            
                <li><a href="../classes/plugin.html">plugin</a></li>
            
                <li><a href="../classes/Pointer.html">Pointer</a></li>
            
                <li><a href="../classes/Pointers.html">Pointers</a></li>
            
                <li><a href="../classes/Polygon.html">Polygon</a></li>
            
                <li><a href="../classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="../classes/RENDERER.html">RENDERER</a></li>
            
                <li><a href="../classes/RenderTexture.html">RenderTexture</a></li>
            
                <li><a href="../classes/Sprite.html">Sprite</a></li>
            
                <li><a href="../classes/SpritePool.html">SpritePool</a></li>
            
                <li><a href="../classes/State.html">State</a></li>
            
                <li><a href="../classes/StateManager.html">StateManager</a></li>
            
                <li><a href="../classes/support.html">support</a></li>
            
                <li><a href="../classes/Text.html">Text</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
                <li><a href="../classes/Tile.html">Tile</a></li>
            
                <li><a href="../classes/Tilelayer.html">Tilelayer</a></li>
            
                <li><a href="../classes/Tilemap.html">Tilemap</a></li>
            
                <li><a href="../classes/Tileset.html">Tileset</a></li>
            
                <li><a href="../classes/TilingSprite.html">TilingSprite</a></li>
            
                <li><a href="../classes/utils.html">utils</a></li>
            
                <li><a href="../classes/Vector.html">Vector</a></li>
            
                <li><a href="../classes/version.html">version</a></li>
            
                <li><a href="../classes/World.html">World</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\tilemap\Tilelayer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var Container = require(&#x27;../display/Container&#x27;),
    Rectangle = require(&#x27;../geom/Rectangle&#x27;),
    Vector = require(&#x27;../math/Vector&#x27;),
    Texture = require(&#x27;../display/Texture&#x27;),
    Tile = require(&#x27;./Tile&#x27;),
    math = require(&#x27;../math/math&#x27;),
    utils = require(&#x27;../utils/utils&#x27;),
    inherit = require(&#x27;../utils/inherit&#x27;),
    support = require(&#x27;../utils/support&#x27;);

/**
 * The Tilelayer is the visual tiled layer that actually displays on the screen
 *
 * This class will be created by the Tilemap, there shouldn&#x27;t be a reason to
 * create an instance on your own.
 *
 * @class Tilelayer
 * @extends Container
 * @constructor
 * @param map {Tilemap} The tilemap instance that this belongs to
 * @param layer {Object} All the settings for the layer
 */
//see: https://github.com/GoodBoyDigital/pixi.js/issues/48
var Tilelayer = function(map, layer) {
    Container.call(this, layer);

    /**
     * The map instance this tilelayer belongs to
     *
     * @property map
     * @type Tilemap
     */
    this.map = map;

    /**
     * The state instance this tilelayer belongs to
     *
     * @property state
     * @type Game
     */
    this.state = map.state;

    /**
     * The state instance this tilelayer belongs to
     *
     * @property state
     * @type Game
     */
    this.state = map.state;

    /**
     * The current map of all tiles on the screen
     *
     * @property tiles
     * @type Object
     */
    this.tiles = [];

    /**
     * The name of the layer
     *
     * @property name
     * @type String
     * @default &#x27;&#x27;
     */
    this.name = layer.name || &#x27;&#x27;;

    /**
     * The size of the layer
     *
     * @property size
     * @type Vector
     * @default new Vector(1, 1)
     */
    this.size = new Vector(layer.width || 0, layer.height || 0);

    /**
     * The tile IDs of the tilemap
     *
     * @property tileIds
     * @type Uint32Array
     */
    this.tileIds = support.typedArrays ? new Uint32Array(layer.data) : layer.data;

    /**
     * The user-defined properties of this group. Usually defined in the TiledEditor
     *
     * @property properties
     * @type Object
     */
    this.properties = utils.parseTiledProperties(layer.properties) || {};

    /**
     * The Tiled type of tile layer, should always be &#x27;tilelayer&#x27;
     *
     * @property type
     * @type String
     * @default &#x27;tilelayer&#x27;
     */
    this.type = layer.type || &#x27;tilelayer&#x27;;

    /**
     * Is this layer supposed to be preRendered?
     *
     * @property preRender
     * @type Boolean
     * @default false
     */
    this.preRender = layer.preRender || this.properties.preRender || false;

    /**
     * The size of a chunk when pre rendering
     *
     * @property chunkSize
     * @type Vector
     * @default new Vector(512, 512)
     */
    this.chunkSize = new Vector(
        layer.chunkSizeX || layer.chunkSize || this.properties.chunkSizeX || this.properties.chunkSize || 512,
        layer.chunkSizeY || layer.chunkSize || this.properties.chunkSizeY || this.properties.chunkSize || 512
    );

    //translate some tiled properties to our inherited properties
    this.position.x = layer.x || 0;
    this.position.y = layer.y || 0;
    this.alpha = layer.opacity !== undefined ? layer.opacity : 1;
    this.visible = layer.visible !== undefined ? layer.visible : true;

    //some private trackers
    this._preRendered = false;
    this._tilePool = [];
    this._buffered = { left: false, right: false, top: false, bottom: false };
    this._panDelta = new Vector();
    this._rendered = new Rectangle();
};

inherit(Tilelayer, Container, {
    /**
     * Creates all the tile sprites needed to display the layer
     *
     * @method resize
     * @param width {Number} The number of tiles in the X direction to render
     * @param height {Number} The number of tiles in the Y direction to render
     * @return {Tilelayer} Returns itself.
     * @chainable
     */
    render: function(x, y, width, height) {
        if(this.preRender) {
            if(!this._preRendered) {
                this._preRender();
            } else {
                for(var c = this.children.length - 1; c &gt; -1; --c) {
                    this.children[c].visible = true;
                }
            }

            return;
        }

        //copy down our tilesize
        if(!this.tileSize)
            this.tileSize = this.map.tileSize;

        //clear all the visual tiles
        this.clearTiles();

        //render the tiles on the screen
        this._renderTiles(x, y, width, height);

        return this;
    },
    /**
     * Renders the map onto different canvases, one per chunk. This only runs once
     * then the canvases are used as a textures for tiles the size of chunks.
     *
     * @method _preRender
     * @private
     */
    _preRender: function() {
        if(!this.visible)
            return;

        this._preRendered = true;
        this.tileSize = this.chunkSize.clone();

        var world = this.map,
            width = world.size.x * world.tileSize.x,
            height = world.size.y * world.tileSize.y,
            xChunks = math.ceil(width / this.chunkSize.x),
            yChunks = math.ceil(height / this.chunkSize.y);

        //for each chunk
        for(var x = 0; x &lt; xChunks; ++x) {
            for(var y = 0; y &lt; yChunks; ++y) {
                var cw = (x === xChunks - 1) ? width - (x * this.chunkSize.x) : this.chunkSize.x,
                    ch = (y === yChunks - 1) ? height - (y * this.chunkSize.y) : this.chunkSize.y;

                this._preRenderChunk(x, y, cw, ch);
            }
        }
    },
    /**
     * Renders a single chunk to a single canvas and creates/places the tile instance for it.
     *
     * @method _preRenderChunk
     * @param cx {Number} The x-coord of this chunk&#x27;s top left
     * @param cy {Number} The y-coord of this chunk&#x27;s top left
     * @param w {Number} The width of this chunk
     * @param h {Number} The height of this chunk
     * @private
     */
    _preRenderChunk: function(cx, cy, w, h) {
        var world = this.map,
            tsx = world.tileSize.x,
            tsy = world.tileSize.y,
            xTiles = w / tsx,
            yTiles = h / tsy,
            nx = (cx * this.chunkSize.x) % tsx,
            ny = (cy * this.chunkSize.y) % tsy,
            tx = math.floor(cx * this.chunkSize.x / tsx),
            ty = math.floor(cy * this.chunkSize.y / tsy),
            sx = world.size.x,
            sy = world.size.y,
            canvas = document.createElement(&#x27;canvas&#x27;),
            ctx = canvas.getContext(&#x27;2d&#x27;);

        canvas.width = w;
        canvas.height = h;

        //draw all the tiles in this chunk to the canvas
        for(var x = 0; x &lt; xTiles; ++x) {
            for(var y = 0; y &lt; yTiles; ++y) {
                if(x + tx &lt; sx &amp;&amp; y + ty &lt; sy) {
                    var id = ((x + tx) + ((y + ty) * sx)),
                        tid = this.tileIds[id],
                        set = world.getTileset(tid),
                        tex, frame;

                    if(set) {
                        tex = set.getTileTexture(tid);
                        frame = tex.frame;

                        ctx.drawImage(
                            tex.baseTexture.source,
                            frame.x,
                            frame.y,
                            frame.width,
                            frame.height,
                            (x * tsx) - nx + set.tileoffset.x,
                            (y * tsy) - ny + set.tileoffset.y,
                            frame.width,
                            frame.height
                        );
                    }
                }
            }
        }

        //use the canvas as a texture for a tile to display
        var tile = new Tile(Texture.fromCanvas(canvas));
        tile.setPosition(
            cx * this.chunkSize.x,
            cy * this.chunkSize.y
        );

        if(!this.tiles[cx])
            this.tiles[cx] = {};

        this.addChild(tile);
        this.tiles[cx][cy] = tile;
    },
    /**
     * Renders the tiles for the viewport
     *
     * @method _renderTiles
     * @param sx {Number} The x-coord in the map to start rendering
     * @param sy {Number} The y-coord in the map to start rendering
     * @param sw {Number} The width of the viewport
     * @param sh {Number} The height of the viewport
     * @private
     */
    _renderTiles: function(sx, sy, sw, sh) {
        //convert to tile coords
        sx = math.floor(sx / this.map.scaledTileSize.x);
        sy = math.floor(sy / this.map.scaledTileSize.y);

        //ensure we don&#x27;t go below 0
        sx = sx &lt; 0 ? 0 : sx;
        sy = sy &lt; 0 ? 0 : sy;

        //convert to tile sizes
        sw = math.ceil(sw / this.map.scaledTileSize.x) + 1;
        sh = math.ceil(sh / this.map.scaledTileSize.y) + 1;

        //ensure we don&#x27;t go outside the map size
        sw = (sx + sw &gt; this.map.size.x) ? (this.map.size.x - sx) : sw;
        sh = (sy + sh &gt; this.map.size.y) ? (this.map.size.y - sy) : sh;

        //render new sprites
        var endX = sx + sw,
            endY = sy + sh;

        for(var x = sx; x &lt; endX; ++x) {
            for(var y = sy; y &lt; endY; ++y) {
                this.moveTileSprite(-1, -1, x, y);
            }
        }

        //set rendered area
        this._rendered.x = sx;
        this._rendered.y = sy;
        this._rendered.width = sw;
        this._rendered.height = sh;

        //reset buffered status
        this._buffered.left = this._buffered.right = this._buffered.top = this._buffered.bottom = false;

        //reset panDelta
        this._panDelta.x = this.state.world.position.x % this.map.scaledTileSize.x;
        this._panDelta.y = this.state.world.position.y % this.map.scaledTileSize.y;
    },
    /**
     * Frees a tile in the list back into the pool
     *
     * @method _freeTile
     * @param tx {Number} The x-coord of the tile in tile coords (not world coords)
     * @param ty {Number} The y-coord of the tile in tile coords (not world coords)
     * @private
     */
    _freeTile: function(tx, ty) {
        if(this.tiles[tx] &amp;&amp; this.tiles[tx][ty]) {
            this.clearTile(this.tiles[tx][ty]);
            this.tiles[tx][ty] = null;
        }
    },
    /**
     * Clears all the tiles currently used to render the layer
     *
     * @method clearTiles
     * @param remove {Boolean} Should this tile be completely removed (never to bee seen again)
     * @return {Tilelayer} Returns itself.
     * @chainable
     */
    clearTiles: function(remove) {
        var c;

        if(this.preRender &amp;&amp; !remove) {
            for(c = this.children.length - 1; c &gt; -1; --c) {
                this.children[c].visible = false;
            }

            return;
        }

        //force rerender later
        this._preRendered = false;

        for(c = this.children.length - 1; c &gt; -1; --c) {
            this.clearTile(this.children[c], remove);
        }

        this.tiles.length = 0;

        return this;
    },
    /**
     * Clears a tile currently used to render the layer
     *
     * @method clearTile
     * @param tile {Tile} The tile object to clear
     * @param remove {Boolean} Should this tile be completely removed (never to bee seen again)
     * @return {Tilelayer} Returns itself.
     * @chainable
     */
    clearTile: function(tile, remove) {
        tile.visible = false;
        tile.disablePhysics();

        if(remove)
            this.removeChild(tile);
        else
            this._tilePool.push(tile);

        return this;
    },
    /**
     * Moves a tile sprite from one position to another, and creates a new tile
     * if the old position didn&#x27;t have a sprite
     *
     * @method moveTileSprite
     * @param fromTileX {Number} The x coord of the tile in units of tiles (not pixels) to move from
     * @param fromTileY {Number} The y coord of the tile in units of tiles (not pixels) to move from
     * @param toTileX {Number} The x coord of the tile in units of tiles (not pixels) to move to
     * @param toTileY {Number} The y coord of the tile in units of tiles (not pixels) to move to
     * @return {Tile} The sprite to display
     */
    moveTileSprite: function(fromTileX, fromTileY, toTileX, toTileY) {
        //if off the map, just ignore it
        if(toTileX &lt; 0 || toTileY &lt; 0 || toTileX &gt;= this.map.size.x || toTileY &gt;= this.map.size.y) {
            //remove the from tile&#x27;s physics
            if(this.tiles[fromTileX] &amp;&amp; this.tiles[fromTileX][fromTileY]) {
                this.tiles[fromTileX][fromTileY].disablePhysics();
            }
            return;
        }

        var tile,
            id = (toTileX + (toTileY * this.size.x)),
            tileId = this.tileIds[id],
            set = this.map.getTileset(tileId),
            texture,
            props,
            position,
            hitArea,
            interactive;

        //if no tileset, just ensure the &quot;from&quot; tile is put back in the pool
        if(!set) {
            this._freeTile(fromTileX, fromTileY);
            return;
        }

        //grab some values for the tile
        texture = set.getTileTexture(tileId);
        props = set.getTileProperties(tileId);
        hitArea = props.hitArea || set.properties.hitArea;
        interactive = this._getInteractive(set, props);
        position = [
            (toTileX * this.map.tileSize.x) + set.tileoffset.x,
            (toTileY * this.map.tileSize.y) + set.tileoffset.y
        ];

        //due to the fact that we use top-left anchors for everything, but tiled uses bottom-left
        //we need to move the position of each tile down by a single map-tile height. That is why
        //there is an addition of &quot;this.map.tileSize.y&quot; to the coords
        position[1] +=  this.map.tileSize.y;

        //if there is one to move in the map, lets just move it
        if(this.tiles[fromTileX] &amp;&amp; this.tiles[fromTileX][fromTileY]) {
            tile = this.tiles[fromTileX][fromTileY];
            this.tiles[fromTileX][fromTileY] = null;
            tile.disablePhysics();
        }
        //otherwise grab a new tile from the pool
        else {
            tile = this._tilePool.pop();
        }

        //if we couldn&#x27;t find a tile from the pool, or one to move
        //then create a new tile
        if(!tile) {
            tile = new Tile(texture);
            tile.anchor.y = 1;
            this.addChild(tile);
        }

        tile.collisionType = props.type;
        tile.interactive = interactive;
        tile.hitArea = hitArea;
        tile.mass = props.mass || 0;

        tile.setTexture(texture);
        tile.setPosition(position[0], position[1]);
        tile.show();

        if(tile.mass) {
            tile.enablePhysics(this.state.physics);
        }

        //pass through all events
        if(interactive) {
            tile.click = this.onTileEvent.bind(this, &#x27;click&#x27;, tile);
            tile.mousedown = this.onTileEvent.bind(this, &#x27;mousedown&#x27;, tile);
            tile.mouseup = this.onTileEvent.bind(this, &#x27;mouseup&#x27;, tile);
            tile.mousemove = this.onTileEvent.bind(this, &#x27;mousemove&#x27;, tile);
            tile.mouseout = this.onTileEvent.bind(this, &#x27;mouseout&#x27;, tile);
            tile.mouseover = this.onTileEvent.bind(this, &#x27;mouseover&#x27;, tile);
            tile.mouseupoutside = this.onTileEvent.bind(this, &#x27;mouseupoutside&#x27;, tile);
        }

        //update sprite position in the map
        if(!this.tiles[toTileX])
            this.tiles[toTileX] = [];

        this.tiles[toTileX][toTileY] = tile;

        return tile;
    },
    /**
     * Called whenever a tile event occurs, this is used to echo to the parent.
     *
     * @method onTileEvent
     * @param eventName {String} The name of the event
     * @param tile {Tile} The tile the event happened to
     * @param data {mixed} The event data that was passed along
     * @private
     */
    onTileEvent: function(eventName, tile, data) {
        this.map.onTileEvent(eventName, tile, data);
    },
    /**
     * Checks if an object should be marked as interactive
     *
     * @method _getInteractive
     * @param set {Tileset} The tileset for the object
     * @param props {Object} The Tiled properties object
     * @return {Boolean} Whether or not the item is interactive
     * @private
     */
    _getInteractive: function(set, props) {
        //first check the lowest level value (on the tile iteself)
        return props.interactive || //obj interactive
                (set &amp;&amp; set.properties.interactive) || //tileset interactive
                this.properties.interactive || //layer interactive
                this.map.properties.interactive; //map interactive
    },
    /**
     * Pans the layer around, rendering stuff if necessary
     *
     * @method pan
     * @param dx {Number|Point} The x amount to pan, if a Point is passed the dy param is ignored
     * @param dy {Number} The y ammount to pan
     * @return {Tilelayer} Returns itself.
     * @chainable
     */
    pan: function(dx, dy) {
        if(this.preRender)
            return;

        //track panning delta so we know when to render
        this._panDelta.x += dx;
        this._panDelta.y += dy;

        var tszX = this.map.scaledTileSize.x,
            tszY = this.map.scaledTileSize.y;

        //check if we need to build a buffer around the viewport
        //usually this happens on the first pan after a full render
        //caused by a viewport resize. We do this buffering here instead
        //of in the initial render because in the initial render, the buffer
        //may try to go negative which has no tiles. Plus doing it here
        //reduces the number of tiles that need to be created initially.

        //moving world right, so left will be exposed
        if(dx &gt; 0 &amp;&amp; !this._buffered.left)
            this._renderLeft(this._buffered.left = true);
        //moving world left, so right will be exposed
        else if(dx &lt; 0 &amp;&amp; !this._buffered.right)
            this._renderRight(this._buffered.right = true);

        //moving world down, so top will be exposed
        if(dy &gt; 0 &amp;&amp; !this._buffered.top)
            this._renderUp(this._buffered.top = true);
        //moving world up, so bottom will be exposed
        else if(dy &lt; 0 &amp;&amp; !this._buffered.bottom)
            this._renderDown(this._buffered.bottom = true);

        //Here is where the actual panning gets done, we check if the pan
        //delta is greater than a scaled tile and if so pan that direction.
        //The reason we do it in a while loop is because the delta can be
        //large than 1 scaled tile and may require multiple render pans
        //(this can happen if you can .pan(x, y) with large values)

        //moved position right, so render left
        while(this._panDelta.x &gt;= tszX) {
            this._renderLeft();
            this._panDelta.x -= tszX;
        }

        //moved position left, so render right
        while(this._panDelta.x &lt;= -tszX) {
            this._renderRight();
            this._panDelta.x += tszX;
        }

        //moved position down, so render up
        while(this._panDelta.y &gt;= tszY) {
            this._renderUp();
            this._panDelta.y -= tszY;
        }

        //moved position up, so render down
        while(this._panDelta.y &lt;= -tszY) {
            this._renderDown();
            this._panDelta.y += tszY;
        }
    },
    /**
     * Renders tiles to the left, pulling from the far right
     *
     * @method _renderLeft
     * @param [forceNew=false] {Boolean} If set to true, new tiles are created instead of trying to recycle
     * @private
     */
    _renderLeft: function(forceNew) {
        //move all the far right tiles to the left side
        for(var i = 0; i &lt; this._rendered.height + 1; ++i) {
            this.moveTileSprite(
                forceNew ? -1 : this._rendered.right,
                forceNew ? -1 : this._rendered.top + i,
                this._rendered.left - 1,
                this._rendered.top + i
            );
        }
        this._rendered.x--;
        if(forceNew) this._rendered.width++;
    },
    /**
     * Renders tiles to the right, pulling from the far left
     *
     * @method _renderRight
     * @param [forceNew=false] {Boolean} If set to true, new tiles are created instead of trying to recycle
     * @private
     */
    _renderRight: function(forceNew) {
        //move all the far left tiles to the right side
        for(var i = 0; i &lt; this._rendered.height + 1; ++i) {
            this.moveTileSprite(
                forceNew ? -1 : this._rendered.left,
                forceNew ? -1 : this._rendered.top + i,
                this._rendered.right + 1,
                this._rendered.top + i
            );
        }
        if(!forceNew) this._rendered.x++;
        if(forceNew) this._rendered.width++;
    },
    /**
     * Renders tiles to the top, pulling from the far bottom
     *
     * @method _renderUp
     * @param [forceNew=false] {Boolean} If set to true, new tiles are created instead of trying to recycle
     * @private
     */
    _renderUp: function(forceNew) {
        //move all the far bottom tiles to the top side
        for(var i = 0; i &lt; this._rendered.width + 1; ++i) {
            this.moveTileSprite(
                forceNew ? -1 : this._rendered.left + i,
                forceNew ? -1 : this._rendered.bottom,
                this._rendered.left + i,
                this._rendered.top - 1
            );
        }
        this._rendered.y--;
        if(forceNew) this._rendered.height++;
    },
    /**
     * Renders tiles to the bottom, pulling from the far top
     *
     * @method _renderDown
     * @param [forceNew=false] {Boolean} If set to true, new tiles are created instead of trying to recycle
     * @private
     */
    _renderDown: function(forceNew) {
        //move all the far top tiles to the bottom side
        for(var i = 0; i &lt; this._rendered.width + 1; ++i) {
            this.moveTileSprite(
                forceNew ? -1 : this._rendered.left + i,
                forceNew ? -1 : this._rendered.top,
                this._rendered.left + i,
                this._rendered.bottom + 1
            );
        }
        if(!forceNew) this._rendered.y++;
        if(forceNew) this._rendered.height++;
    },
    /**
     * Destroys the tile layer completely
     *
     * @method destroy
     */
    destroy: function() {
        Container.prototype.destroy.call(this);

        this.clearTiles(true);

        this.state = null;
        this.name = null;
        this.size = null;
        this.tileIds = null;
        this.properties = null;
        this.type = null;
        this.position.x = null;
        this.position.y = null;
        this.alpha = null;
        this.visible = null;
        this.preRender = null;
        this.chunkSize = null;

        this._preRendered = null;
        this._tilePool = null;
        this._buffered = null;
        this._panDelta = null;
        this._rendered = null;
    }
});

module.exports = Tilelayer;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
